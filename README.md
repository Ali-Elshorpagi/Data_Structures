# Data Structures in C++

###### All of these Data Structures were built using Templates
###### `Function that written in that README is the basic function only`

 ### Table of Contents:
   - [Vector](#1) 
   - [Singly LinkedList](#2) 
   - [Doubly LinkedList](#3) 
   - [Spare Array Using LinkedList](#4) 
   - [Spare Matrix Using LinkedList](#5) 
   - [Spare Cube Using LinkedList](#6) 
   - [Stack Array Based](#7) 
   - [Stack LinkedList Based](#8) 
   - [Circular Queue](#9) 
   - [Queue LinkedList Based](#10) 
   - [Deque](#11) 
   - [Binary Tree](#12) 
   - [Binary Search Tree ( Binary Node )](#13) 
   - [Binary Search Tree](#14) 
   - [Min Binary Heap](#15) 
   - [Max Binary Heap](#16) 
   - [Priority Queue Heap Based](#17) 
   - [Priority Queue AVL Tree Based](#18) 
   - [AVL Tree ( Binary Node )](#19) 
   - [AVL Tree](#20) 
   - [Trie Tree ( Letter )](#21) 
   - [Hash Table](#22) 

### Contents:

- > <a id="1"></a>[**Vector**](header/Vector.h)
     - Push Back
     - Insert
     - Pop
     - Rotate (Left - Right)
     - Find
     - Find Transposition
- > <a id="2"></a>[**Singly LinkedList**](header/Singly_LinkedList.h)
     - Insert (End - Front - After - Alternative)
     - Search
     - Delete (First - Last)
- > <a id="3"></a>[**Doubly LinkedList**](header/Doubly_LinkedList.h)
     - Insert (End - Front - Sorted)
     - Delete (Front - End)
     - Is Palindrom
     - Middle Value
- > <a id="4"></a>[**Spare Array Using LinkedList**](header/Spare_Array.h)
     - Print Row
     - Print Row Non zero
- > <a id="5"></a>[**Spare Matrix Using LinkedList**](header/Sparse_Matrix.h)
     - Print Matrix
     - Print Matrix Non zero
- > <a id="6"></a>[**Spare Cube Using LinkedList**](header/Spare_Cube.h)
     - Print Cube
     - Print Cube Non zero
- > <a id="7"></a>[**Stack Array Based**](header/Stack_Array_Based.h)
     - Is Full
     - Is Empty
     - Push
     - Pop
     - Peek
     - Reverse (Subwords - Num)
     - Remove Adjacent Duplicates
     - Reverse
     - Insert at Bottom
- > <a id="8"></a>[**Stack LinkedList Based**](header/Stack_LinkedList_Based.h)
     - Push
     - Pop
     - Peek
- > <a id="9"></a>[**Circular Queue**](header/Circular_Queue.h)
     - Is Full
     - Is Empty
     - Next
     - Enqueue
     - Dequeue
- > <a id="10"></a>[**Queue LinkedList Based**](header/Queue_LinkedList_Based.h)
     - Is Empty
     - Enqueue
     - Dequeue
- > <a id="11"></a>[**Deque**](header/Deque.h)
     - Next
     - Prev
     - Enqueue (Rear - Front)
     - Dequeue (Rear - Front)
     - Is Empty
     - Is Full
- > <a id="12"></a>[**Binary Tree**](header/Binary_Tree.h)
     - Print (Pre order - Post order - In order)
     - Tree max
     - Tree Height
     - Is exists
     - Is Perfect
     - Traverse
     - Level order Traversal
     - Is Mirror
     - Is symmetric
     - Is Flip
- > <a id="13"></a>[**Binary Search Tree ( Binary Node )**](header/Binary_Search_Tree_v2.h)
     - Insert
     - Search
     - Level Order Traversal
- > <a id="14"></a>[**Binary Search Tree**](header/Binary_Search_Tree.h)
     - Insert
     - Search
     - Delete
     - Get (In Order - Pre Order)
- > <a id="15"></a>[**Min Binary Heap**](header/Min_Heap.h)
     - Push
     - Pop
     - Is empty
     - Heap Sort
- > <a id="16"></a>[**Max Binary Heap**](header/Max_Heap.h)
     - Push
     - Pop
     - Top
     - Is Empty
- > <a id="17"></a>[**Priority Queue Heap Based**](header/Priority_Queue_Heap_Based.h)
     - Is Empty
     - Enqueue
     - Dequeue
- > <a id="18"></a>[**Priority Queue AVL Tree Based**](header/Priority_Queue_AVLT_Based.h)
     - Is Empty
     - Enqueue
     - Dequeue
- > <a id="19"></a>[**AVL Tree ( Binary Node )**](header/AVL_Tree.h)
     - Insert
     - Search
     - Delete
     - Level Order Traversal
     - Lower Bound
     - Upper Bound
     - Prefix Exist
- > <a id="20"></a>[**AVL Tree**](header/AVL_Tree_v2.h)
     - Insert
     - Delete
     - Level Order Traversal
- > <a id="21"></a>[**Trie Tree ( Letter )**](header/Trie_Tree.h)
     - Insert
     - Word Exist
     - Prefix Exist
- > <a id="22"></a>[**Hash Table**]()
    - Hash Table LinkedList Based ( Chaining Technique )
    - Hash Table Vector Based ( Chaining Technique )
    - Hash Table Vector Based ( Linear Probing Technique )
    - Hash Table Vector Based ( Quadratic Probing Technique )
